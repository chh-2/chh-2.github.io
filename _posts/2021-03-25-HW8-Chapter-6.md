---
layout: post
title: "Chapter 6"
---

It’s interesting how databases are so integral to many mid to large scale applications and yet the one database course I’ve taken (while quite useful) examined databases as a standalone entity and no other course has so much as mentioned the integration between databases and a software project in any significant way. I wonder if this would be something useful to touch on explicitly, and if so, in what course would it best fit under the current curriculum? In fact, I’m not sure that I’ve ever created anything persistent in analog with a course, even though some level of persistence seems to be a staple in most large-scale projects I can think of.  
After reading the first two sections of this chapter, I feel like I’ve just had a crash-course database refresher. It might be confusing for someone who didn’t know databases at all, but I think it could also serve well as a cursory level overview of databases and their functionalities. Discussing database security and lease-privileged access was a nice inclusion. It may be necessary to include levels of security when implementing database interactions so that not everyone can interact with every part of the database, but these small types of mentions are the closest I’ve seen in most classes to secure coding principles. The same line of thought applies to the next section on database integrity.  

Yet another thing that makes complete sense but that I’ve never considered: a database abstraction layer. Seems useful, but… well, abstract. That’s honestly something else that would be useful and interesting to explore more deeply in another class: developing interfaces and abstract classes, and working with inheritance and similar topics outside the scope of the first three programing classes but with a little more implementation practice than our theory-heavy course load tends to hit on.  

Also, if we performed database testing in a significant way, I don’t particularly remember that (although to be fair it was the first semester of all classes being online, so many things from that semester are a blur to me). Testing the database would fit in nicely with integrating the database with another coding language. I enjoy seeing how this book has addressed the idea of ‘release early, release often’ as it applies to different aspects of the project. Front end pages are going to be different from database manipulations which integrate with other back end functionality that may or may not be readily apparent to the user.  

One idea from UI/UX design that’s been useful to me in thinking about the concepts has been the idea that, to the average user, the front end is the application. They don’t necessarily distinguish between functionality as it differs from the interface. This is an important consideration for any application, but especially one that will commonly be used by non-technical users. If a functionality exists within an app but how to access this functionality isn’t apparent from the front end, the feature might as well not exist to the average end user. This might not apply quite as deeply to the database design and testing portions on average, but I feel like it still offers a different perspective that may be useful to consider, at the very least.  
