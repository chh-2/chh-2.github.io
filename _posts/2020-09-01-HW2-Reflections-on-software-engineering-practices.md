---
layout: post
title: "HW2: Reflections on Software Engineering Best Practices"
---

Three articles, "No Silver Bullet," "Kode Vicious," and "Google Code Repo" all express concerns and possible approaches to developing and scaling software solutions.  

The first two articles, in particular, address common concerns when it comes to developing a code base including scalability and version control/bug patching as the software scales. Despite all the innovations made over the last 3+ decades, there is still no catch all solution for any given problem. Least of all for when code grows too much or too fast between versions. This often creates problems based in user error, either in implementation of new tools or because the design of the tools themselves was unclear (or because users tried to push the utility of these tools beyond their intended bounds). Regardless of the details, these human-oriented problems also need human-oriented solutions.  

We cannot rely on software to fix fundamental logic errors in our code bases, and many tools (even as simple as the humble flowchart) are implemented at too late a stage to help comprehend the problem in a meaningful way. The fact that Google stores nearly all of their code in a single repository is all we need to see that existing solutions can scale--if their implementation is properly planned. AI, higher level languages, and other coding advances will not save the day. At least not any time soon, and not in the way they might in a programmer’s hopes and dreams. In the vein of “two types of people” jokes, often centered around programming-style logic, it has been said that there are two types of people, those who can extrapolate data from missing information… 
Problems born out of poor planning have only one fundamental solution.  

This becomes more true as software scales, but this truth is inherent as soon as the software is developed. Just because these problems may not show themselves until the software starts to scale, it doesn’t mean they weren’t present from the program’s inception. Even from the program’s conceptualization, if it was known the solution was intended to service a wide audience or a large number of users. This is something that must be understood by developers even before they begin to develop, in order for them to have the best results and the least hangups downstream in their development. And the more people that become involved in a project, the more communication and standards need to be set at an early stage.  

You can see this with any school group project. In early grade levels, much of the planning and guidance is performed by the teacher--leading to multiple copies of a product all conceived under the same guidelines. Going into high school and college, when more freedom and autonomy is placed in the hands of the students, there may not be any sense of urgency to plan or work on the project, or it may be simple enough they don’t feel that pre-planning and communication is necessary before implementation. Especially at the college level, this often manifests itself in last-minute cram sessions or all-nighters to complete the project on time, whether all group members work on it together or whether one person ends up shouldering the weight of an entire group’s workload. Seeing this pattern continue in some people through senior year, why should anyone believe that this practice will magically improve as the student graduates into the workforce if it was never taught to them at any point in their educational career?  
